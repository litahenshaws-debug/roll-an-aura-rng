// =======================================================
// CORE SETUP (Three.js)
// =======================================================

// 1. Scene
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xadd8e6); // Light blue sky

// 2. Camera
const camera = new THREE.PerspectiveCamera( 
    75, 
    window.innerWidth / window.innerHeight, 
    0.1, 
    1000 
);

// 3. Renderer
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize( window.innerWidth, window.innerHeight );
document.body.appendChild( renderer.domElement );

// Handle window resizing
window.addEventListener('resize', () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
});

// =======================================================
// PHYSICS SETUP (Cannon.js)
// =======================================================

const world = new CANNON.World();
world.gravity.set(0, -9.82, 0); // Standard gravity
world.broadphase = new CANNON.NaiveBroadphase();
const timeStep = 1 / 60; // Physics update frequency

// =======================================================
// LEVEL GEOMETRY (Three.js Meshes & Cannon.js Bodies)
// =======================================================

// --- GROUND ---
const groundGeometry = new THREE.BoxGeometry( 20, 1, 20 ); 
const groundMaterial = new THREE.MeshLambertMaterial( { color: 0x888888 } );
const ground = new THREE.Mesh( groundGeometry, groundMaterial );
scene.add( ground );

const groundHalfExtents = new CANNON.Vec3(10, 0.5, 10); 
const groundShape = new CANNON.Box(groundHalfExtents);
const groundBody = new CANNON.Body({
    mass: 0, // Static object
    shape: groundShape,
    position: new CANNON.Vec3(0, -0.5, 0) // Position matches the Three.js mesh
});
world.addBody(groundBody);


// --- PLAYER ---
const playerGeometry = new THREE.BoxGeometry( 1, 1, 1 );
const playerMaterial = new THREE.MeshPhongMaterial( { color: 0xff0000 } );
const player = new THREE.Mesh( playerGeometry, playerMaterial );
scene.add( player );

const playerHalfExtents = new CANNON.Vec3(0.5, 0.5, 0.5); 
const playerShape = new CANNON.Box(playerHalfExtents);
const playerBody = new CANNON.Body({
    mass: 5, // Dynamic object (affected by gravity)
    shape: playerShape,
    position: new CANNON.Vec3(0, 5, 0) // Start player high up to demonstrate falling
});
world.addBody(playerBody);


// --- COIN (Collectible) ---
const coinGeometry = new THREE.CylinderGeometry( 0.3, 0.3, 0.05, 16 ); 
const coinMaterial = new THREE.MeshPhongMaterial( { color: 0xffd700 } ); 
const coin = new THREE.Mesh( coinGeometry, coinMaterial );
coin.position.set( 5, 2, 0 ); 
scene.add( coin );

// Cannon Body for the Coin
const coinShape = new CANNON.Cylinder( 0.3, 0.3, 0.05, 16 );
const coinBody = new CANNON.Body({
    mass: 0, 
    shape: coinShape,
    position: new CANNON.Vec3(5, 2, 0)
});
// CRITICAL: Set collisionResponse to 0 so the player can pass through it (it's a trigger)
coinBody.collisionResponse = 0; 
world.addBody(coinBody);

// Array to track all active coins
const collectibles = [{ mesh: coin, body: coinBody }];


// =======================================================
// LIGHTING
// =======================================================
const ambientLight = new THREE.AmbientLight( 0x404040, 5 ); 
scene.add( ambientLight );

const directionalLight = new THREE.DirectionalLight( 0xffffff, 1 );
directionalLight.position.set( 5, 10, 7.5 ); 
scene.add( directionalLight );


// =======================================================
// INPUT HANDLING
// =======================================================
const keys = {}; 
const speed = 5; // Movement speed for the playerBody

document.addEventListener('keydown', (event) => {
    keys[event.code] = true;
});

document.addEventListener('keyup', (event) => {
    keys[event.code] = false;
});


// =======================================================
// COLLISION HANDLER (Coin Collection)
// =======================================================

playerBody.addEventListener('collide', function(event) {
    const collidedBody = event.body; 

    // Find the index of the collided body in our collectibles array
    const coinIndex = collectibles.findIndex(item => item.body === collidedBody);

    if (coinIndex !== -1) {
        // Coin Collected!
        const collectedCoin = collectibles[coinIndex];
        
        // 1. Remove from THREE.js scene (Visual)
        scene.remove(collectedCoin.mesh);
        
        // 2. Remove from CANNON.js world (Physics)
        world.removeBody(collectedCoin.body);
        
        // 3. Remove from our tracking array
        collectibles.splice(coinIndex, 1);
        
        console.log("Coin Collected! Total remaining:", collectibles.length);
    }
});


// =======================================================
// GAME LOOP
// =======================================================

function animate() {
    requestAnimationFrame( animate ); 

    // 1. Physics Update
    world.step(timeStep); 

    // 2. Control Logic (Applying velocity based on keys)
    // We preserve the current Y-velocity (which is gravity/jump)
    let velocity = new CANNON.Vec3(0, playerBody.velocity.y, 0); 
    
    if (keys['KeyW']) { // Forward
        velocity.z = -speed;
    } else if (keys['KeyS']) { // Backward
        velocity.z = speed;
    } else {
        velocity.z = 0; // Stop horizontal movement when keys are released
    }
    
    if (keys['KeyA']) { // Left
        velocity.x = -speed;
    } else if (keys['KeyD']) { // Right
        velocity.x = speed;
    } else {
        velocity.x = 0; // Stop horizontal movement when keys are released
    }

    // Set the new calculated velocity back to the player body
    playerBody.velocity.set(velocity.x, velocity.y, velocity.z); 

    // 3. Synchronization (Copy position/rotation from physics body to visual mesh)
    player.position.copy(playerBody.position);
    player.quaternion.copy(playerBody.quaternion);

    // 4. Coin Animation
    for (const item of collectibles) {
        item.mesh.rotation.y += 0.05; 
    }

    // 5. Camera Follow
    camera.position.x = player.position.x;
    camera.position.z = player.position.z + 5; 
    camera.position.y = player.position.y + 2; 
    camera.lookAt(player.position);

    // 6. Render
    renderer.render( scene, camera );
}

// Start the loop!
animate();
